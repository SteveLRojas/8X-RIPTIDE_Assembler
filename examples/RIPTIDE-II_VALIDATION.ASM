; THIS PROGRAM WILL TEST VARIOUS FUNCTIONS OF THE RIPTIDE-II CPU, AND POST RESULTS AT CERTAIN MEMORY LOCATIONS.
; AFTER ALL TESTS ARE COMPLETED A PORTION OF THE DATA MEMORY IS DUMPED THROUGH A SERIAL PORT.

; MEM DUMP LOCATIONS:
; $00 HAZARD TEST OVF RESULT	EXPECTED: $00
; $01 HAZARD TEST XMIT RESULT 	EXPECTED: $FF
; $02 XEC TEST CLEAR RESULT 	EXPECTED: $00
; $03 XEC TEST SET RESULT		EXPECTED: $FF
; $04 XEC TEST BRANCH PASS/FAIL	EXPECTED: $AA
; $05 XEC IV TEST RESULT		EXPECTED: $00
; $06 XEC IV TEST RESULT		EXPECTED: $FF
; $07 CALL NOP RESULT			EXPECTED: $AA
; $08 CALL SHORT RESULT			EXPECTED: $AA
; $09 CALL RECURSIVE RESULTS	EXPECTED: $07
; $0A		EXPECTED: $06
; $0B		EXPECTED: $05
; $0C		EXPECTED: $04
; $0D		EXPECTED: $03
; $0E		EXPECTED: $02
; $0F		EXPECTED: $01
; $10		EXPECTED: $00
; $11 CALL TEST DONE RESULT		EXPECTED: $AA
; $12 XEC IV TEST INTERMEDIATE RESULT	EXPECTED: $00
; $13 XEC IV TEST INTERMEDIATE RESULT	EXPECTED: $01
; $14 FAST WRITE RESULT		EXPECTED: $07
; $15 FAST WRITE RESULT		EXPECTED: $07
; $16 FAST WRITE RESULT		EXPECTED: $05
; $17 FAST WRITE RESULT		EXPECTED: $0F
; $18 FAST WRITE RESULT		EXPECTED: $0E

; Address map for left bank:
; 0x0000 to 0xFFFB	unused
; 0xFFFC to 0xFFFD	LED register
; 0xFFFE to 0xFFFF	RS-232 module

; Address map for right bank:
; 0x0000 to 0xFFFF	active data memory page (cached)

; Address map for program space:
; 0x0000 to 0xFFFF	active program memory page (cached)

; REMEMBER: PROGRAM MEMORY IS WORD ADDRESSABLE WHILE DATA MEMORY IS BYTE ADDRESSABLE!
; THE TWO MEMORY SPACES ARE SHARED THROUGH THE CACHE CONTROLLERS, BOTH CACHES MUST BE FLUSHED FOR CHANGES TO THE DATA SPACE TO SHOW UP IN THE PROGRAM SPACE.

INCLUDE "8X-RIPTIDE.INC"
	ORG 0
INIT
	XMIT $FF, IVL
	XMIT $FC, IVR
	XMIT $07, LIV3, 4
	XMIT $0F, LIV7, 4	;SET LEDs
	XMIT $00, AUX
	XMIT $00, R1
	XMIT $00, R2
	XMIT $00, R3
	XMIT $00, R4
	XMIT $00, R5
	XMIT $00, R6
	XMIT $00, R11
	JMP FAST_WRITE

MEM_DUMP
	XMIT $00, R1	;INITIALIZE ADDRESS COUNTER
	XMIT $20, R2	;END ADDRESS
	XMIT $FF, AUX
	XOR R2, R2
	XMIT $01, AUX
	ADD R2, R2		;R2 NOW CONTAINS -32
MD_LOOP
;READ DATA FROM MEMORY
	XMIT $00, IVL
	MOVE R1, IVR
	MOVE RIV7, 8, R4
;CHECK THAT UART IS READY
	XMIT $FF, IVL
	XMIT $FF, IVR	;UART STATUS REGISTER
MD_WAIT
	XMIT $01, AUX
	MOVE LIV5, 1, R5 	;READ TX READY BIT
	XOR R5, R5 			;INVERT TX READY BIT
	NZT R5, MD_WAIT			;IF TX NOT READY KEEP WAITING
	XMIT $FF, IVL
	XMIT $FE, IVR 		;UART DATA REGISTER
	MOVE R4, 8, LIV7
;ADD 1 TO ADSRESS
	XMIT $01, AUX
	ADD R1, R1
	MOVE R2, AUX	;SET AUX TO -32
	ADD R1, R3	;SUBTRACT 32 FROM ADDRESS
	NZT R3, MD_LOOP	;IF ADDRESS != 32 DO NEXT ADDRESS
	XMIT $FF, IVL
	XMIT $FC, IVR
	XMIT $0E, LIV3, 4
	XMIT $0F, LIV7, 4	;TURN ON LEDs
	JMP NOP_TEST	;ELSE END

XEC_IV_TEST
	XMIT $AA, R0
;SET DATA ADDRESS TO RAM LOCATION
	XMIT $00, IVL
	XMIT $12, IVR
	XMIT $00, RIV3, 4
	XMIT $00, RIV7, 4	;CLEAR LIV
	XEC CLR_R0 (RIV7, 4)
;POST RESULT
	XMIT $00, IVL
	XMIT $05, IVR
	MOVE R0, 8, RIV7

	XMIT $00, IVL
	XMIT $13, IVR
	XMIT $01, RIV7, 4	;SET LIV TO 1
	XEC CLR_R0 (RIV7, 4)
;POST RESULT
	XMIT $00, IVL
	XMIT $06, IVR
	MOVE R0, 8, RIV7
	JMP XEC_TEST

CLR_R0
	XMIT $00, R0
SET_R0
	XMIT $FF, R0

XEC_TEST
	XMIT $55, R2
	XMIT $00, R0
	XEC CLR_R2 (AUX)
; POST FIRST RESULT
	XMIT $00, IVL
	XMIT $02, IVR
	MOVE R2, 8, RIV7

	XMIT $01, R0
	XEC CLR_R2 (AUX)
; POST SECOND RESULT
	XMIT $00, IVL
	XMIT $03, IVR
	MOVE R2, 8, RIV7

	XMIT $02, R0
	XEC CLR_R2 (AUX)
; POST TEST FAILED
	XMIT $00, IVL
	XMIT $04, IVR
	XMIT $FF, R2
	MOVE R2, 8, RIV7
	JMP NOP_TEST	;HALT CPU

XEC_BRANCH_RETURN
; POST TEST PASSED
	XMIT $00, IVL
	XMIT $04, IVR
	XMIT $AA, R2
	MOVE R2, 8, RIV7
	JMP HAZARD_TEST

CLR_R2
	XMIT $00, R2
SET_R2
	XMIT $FF, R2
XEC_BRANCH
	JMP XEC_BRANCH_RETURN
	
NOP_TEST
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	JMP NOP_TEST

CALL_TEST
	XMIT HIGH SUB_NOP, AUX
	CALL SUB_NOP
	NOP
	NOP
	CALL SUB_SHORT
;POST RESULT
	XMIT $00, IVL
	XMIT $08, IVR
	XMIT $AA, R3
	MOVE R3, 8, RIV7
	XMIT 8, R1
	XMIT $09, R4	;INITIALIZE ADDRESS COUNTER FOR POSTING RESULTS
	CALL SUB_NESTED
SUB_NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
;POST RESULT
	XMIT $00, IVL
	XMIT $07, IVR
	XMIT $AA, R3
	MOVE R3, 8, RIV7
	RET
SUB_SHORT
	RET
SUB_NESTED
	MOVE AUX, R2	;COPY AUX TO R2
	XMIT $FF, AUX	;SET AUX TO -1
	ADD R1, R1	;DECREMENT R1

	XMIT $00, IVL
	MOVE R4(0), IVR
	MOVE R1, 8, RIV7
	XMIT $01, AUX
	ADD R4, R4

	MOVE R2, AUX	;RESTORE AUX
	NZT R1, SN_NEXT	;IF R1 NOT ZERO CALL SUB_NESTED AGAIN
	RET
SN_NEXT
	CALL SUB_NESTED
;POST RESULT
	XMIT $00, IVL
	XMIT $11, IVR
	XMIT $AA, R5
	MOVE R5, 8, RIV7
	JMP MEM_DUMP

HAZARD_TEST_POST
	XMIT $00, IVL
	XMIT $00, IVR	;SET DATA ADDRESS TO $0000
	MOVE OVF, 8, RIV7
	XMIT $01, IVR
	MOVE R1, 8, RIV7
	JMP CALL_TEST

HAZARD_TEST2
	NOP
	NOP
	NOP
	NOP
	NZT AUX, HAZARD_TEST_POST
	XMIT $EE, R1	;R1 SHOULD REMAIN CLEARED

HAZARD_TEST
	XMIT $00, R6
	XMIT $00, AUX
	ADD R6, R6	;CLEAR OVF
	XMIT $FF, R1
	XMIT $01, AUX	;WILL ADD THESE TWO TO CAUSE AN OVERFLOW
	NZT R1, HAZARD_TEST2	;CONDITIONAL BRANCH TO FLUSH PIPELINE
	ADD R1, R1	;OVF SHOULD NOT BE SET
	NOP
	NOP
	NOP
	NOP

FAST_WRITE
	XMIT $DF, IVL
	XMIT $FF, IVR
	XMIT $05, RIV7, 8
	NOP
	NOP
	XMIT $FF, IVL
	XMIT $FF, IVR
	XMIT $00, RIV7, 8
	XMIT $01, RIV7, 8
	XMIT $02, RIV7, 8
	XMIT $03, RIV7, 8
	XMIT $04, RIV7, 8
	XMIT $05, RIV7, 8
	XMIT $06, RIV7, 8
	XMIT $07, RIV7, 8
	XMIT $EF, IVL
	XMIT $00, RIV7, 8
	XMIT $01, RIV7, 8
	XMIT $02, RIV7, 8
	XMIT $03, RIV7, 8
	XMIT $04, RIV7, 8
	XMIT $05, RIV7, 8
	XMIT $06, RIV7, 8
	XMIT $07, RIV7, 8
	XMIT $DF, IVL
	XMIT $CF, IVL
	XMIT $0F, RIV7, 8
	XMIT $BF, IVL
	XMIT $0E, RIV7, 8
	NOP
	NOP
; POST RESULTS
	XMIT $FF, IVL
	XMIT $FF, IVR	;SET DATA ADDRESS TO $FFFF
	MOVE RIV7, 8, AUX	;PUT RESULT IN AUX
	XMIT $00, IVL
	XMIT $14, IVR	;POST AT THIS ADDRESS
	MOVE AUX, 8, RIV7

	XMIT $EF, IVL
	XMIT $FF, IVR
	MOVE RIV7, 8, AUX
	XMIT $00, IVL
	XMIT $15, IVR
	MOVE AUX, 8, RIV7

	XMIT $DF, IVL
	XMIT $FF, IVR
	MOVE RIV7, 8, AUX
	XMIT $00, IVL
	XMIT $16, IVR
	MOVE AUX, 8, RIV7

	XMIT $CF, IVL
	XMIT $FF, IVR
	MOVE RIV7, 8, AUX
	XMIT $00, IVL
	XMIT $17, IVR
	MOVE AUX, 8, RIV7

	XMIT $BF, IVL
	XMIT $FF, IVR
	MOVE RIV7, 8, AUX
	XMIT $00, IVL
	XMIT $18, IVR
	MOVE AUX, 8, RIV7
	JMP LONG_JUMP

LONG_JUMP
	XMIT $FF, IVL
	XMIT $FC, IVR
	XMIT $0B, LIV3, 4
	XMIT $0F, LIV7, 4	;SET LEDs

	XMIT $FF, IVL
	XMIT $FF, IVR
	XMIT $08, RIV3, 4
	XMIT $0F, RIV7, 4
	XMIT $FE, IVR
	XMIT $00, RIV7, 8	;CREATE RET INSTRUCTION AT ADDRESS $7FFF IN PROGRAM SPACE ($FFFF AND FFFE IN DATA SPACE)
	XMIT $0F, IVL
	MOVE RIV7, 8, AUX	;CAUSE CACHE MISS TO MOVE NOP TO MAIN MEMORY
	XMIT $7F, AUX		;SET PAGE REGISTER TO $7F
	CALL $FF	;CALL ADDRESS $7FFF
	
	XMIT $FF, IVL
	XMIT $FC, IVR
	XMIT $0D, LIV3, 4
	XMIT $0F, LIV7, 4	;TURN ON LEDs
	JMP XEC_IV_TEST

	ORG $0FFF	;PAD FILE TO 4K WORDS
	JMP MEM_DUMP